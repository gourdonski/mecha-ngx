{
  "version": 3,
  "file": "mecha-ngx.js",
  "sources": [
    "ng://mecha-ngx/out/src/app/mecha.module.ts",
    "ng://mecha-ngx/out/src/app/http/services/mecha-http/mecha-http.service.ts",
    "ng://mecha-ngx/out/src/app/shared/services/mecha-util/mecha-util.service.ts",
    "ng://mecha-ngx/out/src/app/http/models/mecha-http-response.model.ts",
    "ng://mecha-ngx/out/src/app/shared/services/mecha-cache/mecha-cache.service.ts",
    "ng://mecha-ngx/out/src/app/abstract/cache.abstract.ts",
    "ng://mecha-ngx/out/src/app/abstract/app-config.abstract.ts"
  ],
  "sourcesContent": [
    "import { BrowserModule } from '@angular/platform-browser';\nimport { ModuleWithProviders, NgModule } from '@angular/core';\nimport { HttpClientModule } from '@angular/common/http';\n\nimport { APP_CONFIG, AppConfigInterface } from './abstract/app-config.abstract';\nimport { CACHE, CacheInterface } from './abstract/cache.abstract';\nimport { MechaCacheService } from './shared/services/mecha-cache/mecha-cache.service';\nimport { MechaHttpService } from './http/services/mecha-http/mecha-http.service';\nimport { MechaUtilService } from './shared/services/mecha-util/mecha-util.service';\n\nconst defaultConfig: AppConfigInterface = {\n  cacheTtl: 60000,\n};\n\nexport interface MechaModuleOptionsInterface {\n  appConfig?: AppConfigInterface;\n  cacheClass?: new (...args: any[]) => CacheInterface;\n}\n\n@NgModule({\n  imports: [\n    BrowserModule,\n    HttpClientModule,\n  ],\n  providers: [\n    MechaHttpService,\n    MechaUtilService,\n  ],\n})\nexport class MechaModule {\n  static forRoot({\n      appConfig = defaultConfig,\n      cacheClass = MechaCacheService,\n    }: MechaModuleOptionsInterface): ModuleWithProviders {\n    return {\n      ngModule: MechaModule,\n      providers: [\n        { provide: APP_CONFIG, useValue: appConfig },\n        { provide: CACHE, useClass: cacheClass },\n      ]\n    };\n  }\n}\n",
    "import { Inject, Injectable } from '@angular/core';\nimport { HttpClient, HttpResponse } from '@angular/common/http';\n\nimport * as Immutable from 'immutable';\nimport { AsyncSubject } from 'rxjs/AsyncSubject';\nimport { Observable } from 'rxjs/Observable';\nimport { ReplaySubject } from 'rxjs/ReplaySubject';\nimport { Subject } from 'rxjs/Subject';\nimport 'rxjs/add/observable/interval';\nimport 'rxjs/add/observable/throw';\nimport 'rxjs/add/operator/catch';\nimport 'rxjs/add/operator/debounceTime';\nimport 'rxjs/add/operator/finally';\nimport 'rxjs/add/operator/map';\nimport 'rxjs/add/operator/share';\nimport 'rxjs/add/operator/switchMap';\nimport 'rxjs/add/operator/take';\nimport 'rxjs/add/operator/takeUntil';\n\nimport { APP_CONFIG, AppConfigInterface } from '../../../abstract/app-config.abstract';\nimport { CACHE, CacheInterface } from '../../../abstract/cache.abstract';\nimport { MechaHttpResponse, MechaHttpResponseInterface } from '../../models/mecha-http-response.model';\nimport { MechaUtilService } from '../../../shared/services/mecha-util/mecha-util.service';\n\ninterface RequestNumberInterface { requestNumber: number; }\n\nconst ARBITRARY_TOKEN_VALUE = ' ';\n\n@Injectable()\nexport class MechaHttpService {\n  private _requestLookup: { [key: string]: Subject<any>} = {};\n\n  private _requesterHistory: { [key: string]: RequestNumberInterface } = {};\n\n  private _isDebouncingRequest = false;\n\n  private _debouncedSource: AsyncSubject<MechaHttpResponseInterface<any>>;\n\n  private _cachedSource: AsyncSubject<MechaHttpResponseInterface<any>>;\n\n  private _cachedImmutableSource: AsyncSubject<MechaHttpResponseInterface<any>>;\n\n  constructor(\n    @Inject(APP_CONFIG) private readonly _appConfig: AppConfigInterface,\n    @Inject(CACHE) private readonly _cache: CacheInterface,\n    private readonly _http: HttpClient,\n    private readonly _util: MechaUtilService) { }\n\n  /**\n   * Vanilla get request\n   * @param url URL to get resource from\n   *\n   * @returns The response as an observable\n  */\n  public get<T>(url: string): Observable<MechaHttpResponseInterface<T>> {\n    const requester = 'get';\n\n    return this._http\n      .get(url)\n      .catch(this.handleResponseError)\n      .map((response: HttpResponse<T>) => new MechaHttpResponse<T>({\n        requester: requester,\n        requestNumber: this.getRequestNumber(requester),\n        data: this.getResponseJson<T>(response),\n      }));\n  }\n\n  /**\n   * Share a single request amongst subscribers\n   * @param url URL to get resource from\n   *\n   * @returns The shared response as an observable\n  */\n  public getShared<T>(url: string): Observable<MechaHttpResponseInterface<T>> {\n    const requester = 'getShared';\n\n    return this._http\n      .get(url)\n      .catch(this.handleResponseError)\n      .map((response: HttpResponse<T>) => new MechaHttpResponse<T>({\n        requester: requester,\n        requestNumber: this.getRequestNumber(requester),\n        data: this.getResponseJson<T>(response),\n      }))\n      .share();\n  }\n\n  /**\n   * Thwart spammers with a debounced get\n   * @param url URL to get resource from\n   * @param [debounceInMilliseconds=1000] Length of time to debounce before submitting request\n   *\n   * @returns The debounced response as an observable\n  */\n  public getDebounced<T>(url: string, debounceInMilliseconds: number = 1000): Observable<MechaHttpResponseInterface<T>> {\n    const requester = 'getDebounced';\n\n    if (!this._isDebouncingRequest) {\n      this._debouncedSource = new AsyncSubject();\n\n      // not using switchMap because we don't want to hit backend at all until debounce completes\n      this._http.get(url)\n        .takeUntil(this._debouncedSource)\n        .debounceTime(debounceInMilliseconds)\n        .catch(this.handleResponseError)\n        .map((response: HttpResponse<T>) => new MechaHttpResponse<T>({\n          requester: requester,\n          requestNumber: this.getRequestNumber(requester),\n          data: this.getResponseJson<T>(response),\n        }))\n        .finally(() => this._isDebouncingRequest = false)\n        .subscribe(this._debouncedSource);\n    }\n\n    this._isDebouncingRequest = true;\n\n    return this._debouncedSource;\n  }\n\n /**\n   * Get responses until a condition is met, just because\n   * @param url URL to get resource from\n   * @param cancelToken Token used to cancel the interval\n   * @param [intervalInMilliseconds=1000] Length of time for each interval\n   * @param [numberOfIntervals] Number of times to execute request\n   *\n   * @returns The response in intervals as an observable\n  */\n  public getUntil<T>(url: string, cancelToken: Subject<void>, intervalInMilliseconds: number = 1000, numberOfIntervals?: number):\n    Observable<MechaHttpResponseInterface<T>> {\n    const requester = 'getUntil';\n\n    let getUntil$: Observable<number> = Observable\n      .interval(intervalInMilliseconds)\n      .takeUntil(cancelToken);\n\n    if (numberOfIntervals) {\n      getUntil$ = getUntil$.take(numberOfIntervals);\n    }\n\n    return getUntil$\n      .switchMap(() => this._http.get(url))\n      .catch(this.handleResponseError)\n      .map((response: HttpResponse<T>) => new MechaHttpResponse<T>({\n        requester: requester,\n        requestNumber: this.getRequestNumber(requester),\n        data: this.getResponseJson<T>(response),\n      }))\n      .share();\n  }\n\n  /**\n   * Make sure nothing is messing with your response\n   * @param url URL to get resource from\n   *\n   * @returns The response shared immutably as an observable\n  */\n  public getImmutable<T>(url: string): Observable<MechaHttpResponseInterface<T>> {\n    const requester = 'getImmutable';\n\n    return this._http\n      .get(url)\n      .catch(this.handleResponseError)\n      .map((response: HttpResponse<T>) => Immutable\n        .fromJS(new MechaHttpResponse<T>({\n          requester: requester,\n          requestNumber: this.getRequestNumber(requester),\n          data: this.getResponseJson<T>(response),\n        })))\n      .share()\n      .map((immutable: any) => immutable.toJS());\n  }\n\n  /**\n   * Cache a response to save trips to the backend\n   * @param url URL to get resource from\n   *\n   * @returns The cached response as an observable\n  */\n  public getCached<T>(url: string): Observable<MechaHttpResponseInterface<T>> {\n    const requester = 'getCached';\n\n    const key: number = this._util.getHashCode(url); // hashing URL and using as key in cache\n\n    const token: string = this._cache.find(key);\n\n    // if initial call or cache is expired, make fetch\n    if (token == null) {\n      this._cache.add(key, ARBITRARY_TOKEN_VALUE);\n\n      // clean up existing subject before re-initializing\n      if (this._cachedSource != null) {\n        this._cachedSource.complete();\n      }\n\n      this._cachedSource = new AsyncSubject();\n\n      this._http\n        .get(url)\n        .catch(this.handleResponseError)\n        .map((response: HttpResponse<T>) => new MechaHttpResponse<T>({\n          requester: requester,\n          requestNumber: this.getRequestNumber(requester),\n          data: this.getResponseJson<T>(response),\n        }))\n        .subscribe(this._cachedSource);\n    }\n\n    return this._cachedSource;\n  }\n\n  /**\n   * Cache a response to save trips to the backend and pass immutable copy to subscribers so they don't mess with each other\n   * @param url URL to get resource from\n   *\n   * @returns The cached response shared immutably as an observable\n  */\n  public getCachedImmutable<T>(url: string): Observable<MechaHttpResponseInterface<T>> {\n    const requester = 'getCachedImmutable';\n\n    const key: number = this._util.getHashCode(`immutable${url}`); // hashing URL and using as key in cache\n\n    const token: string = this._cache.find(key);\n\n    // if initial call or cache is expired, make fetch\n    if (token == null) {\n      this._cache.add(key, ARBITRARY_TOKEN_VALUE);\n\n      // clean up existing subject before re-initializing\n      if (this._cachedImmutableSource != null) {\n        this._cachedImmutableSource.complete();\n      }\n\n      this._cachedImmutableSource = new AsyncSubject();\n\n      this._http\n        .get(url)\n        .catch(this.handleResponseError)\n        .map((response: HttpResponse<T>) => Immutable\n          .fromJS(new MechaHttpResponse<T>({\n            requester: requester,\n            requestNumber: this.getRequestNumber(requester),\n            data: this.getResponseJson<T>(response),\n          })))\n        .subscribe(this._cachedImmutableSource);\n    }\n\n    return this._cachedImmutableSource.map((immutable: any) => immutable.toJS());\n  }\n\n  private getRequestNumber(requester: string): number {\n    return ++(this._requesterHistory[requester] = this._requesterHistory[requester] || { requestNumber: 0 }).requestNumber;\n  }\n\n  // the following are based on the Angular Http service doc\n  private getResponseJson<T>(response: HttpResponse<T>): T {\n    return response.body;\n  }\n\n  private handleResponseError(error: any): Observable<string> {\n    let errorMessage: string;\n\n    if (error instanceof HttpResponse) {\n      const json = error.body;\n\n      const err = json.error || JSON.stringify(json);\n\n      errorMessage = `${error.status}${error.statusText ? ' ' + error.statusText : ''} - ${err}`;\n    } else { errorMessage = error.message ? error.message : error.toString(); }\n\n    return Observable.throw(errorMessage);\n  }\n}\n",
    "import { Injectable } from '@angular/core';\n\n@Injectable()\nexport class MechaUtilService {\n  // http://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/\n  /**\n   * Converts a string to a hash code\n   * @param val Value to be hashed\n   *\n   * @returns Hash code generated from input value\n  */\n  public getHashCode(val: any): number {\n    if (!(typeof val === 'string' || val instanceof String)) {\n      return null;\n    }\n\n    let hash = 0;\n\n    let chr;\n\n    if (val.length === 0) {\n      return hash;\n    }\n\n    for (let i = 0; i < val.length; i++) {\n      chr = val.charCodeAt(i);\n      // tslint:disable-next-line:no-bitwise\n      hash = ((hash << 5) - hash) + chr;\n      // tslint:disable-next-line:no-bitwise\n      hash |= 0; // convert to 32-bit integer\n    }\n\n    return hash;\n  }\n}\n",
    "export class MechaHttpResponse<T> {\r\n  public requester: string;\r\n  public requestNumber: number;\r\n  public lastRequestTimestamp: Date | number;\r\n  public data: T;\r\n\r\n  constructor({\r\n    requester,\r\n    requestNumber = 1,\r\n    lastRequestTimestamp = new Date(),\r\n    data,\r\n  }: MechaHttpResponseInterface<T>) {\r\n    this.requester = requester;\r\n    this.requestNumber = requestNumber;\r\n    this.lastRequestTimestamp = lastRequestTimestamp;\r\n    this.data = data;\r\n  }\r\n}\r\n\r\nexport interface MechaHttpResponseInterface<T> {\r\n  requester: string;\r\n  requestNumber: number;\r\n  lastRequestTimestamp?: Date | number;\r\n  data: T;\r\n}\r\n",
    "import { Inject, Injectable } from '@angular/core';\r\n\r\nimport * as molar from 'molar';\r\n\r\nimport { APP_CONFIG, AppConfigInterface } from '../../../abstract/app-config.abstract';\r\nimport { CacheInterface } from '../../../abstract/cache.abstract';\r\n\r\n@Injectable()\r\nexport class MechaCacheService implements CacheInterface {\r\n  // using a simple caching library that checks for expiration on retrieval\r\n  private _cache: molar.ILookup;\r\n\r\n  constructor(@Inject(APP_CONFIG) private readonly _appConfig: AppConfigInterface) {\r\n    this._cache = new molar.Lookup(false, _appConfig.cacheTtl);\r\n  }\r\n\r\n  /**\r\n   * Adds a resource to the cache using a key\r\n   * @param key Key provided to identify the resource in the cache\r\n   * @param value Value for the resource in the cache\r\n   *\r\n   * @returns Flag indicating if resource was successfully added\r\n  */\r\n  public add(key: any, value: any): boolean {\r\n    return this._cache.add(key, value);\r\n  }\r\n\r\n  /**\r\n   * Removes a resource from the cache by key\r\n   * @param key Key provided to identify the resource in the cache\r\n   *\r\n   * @returns Flag indicating if removal was successful\r\n  */\r\n  public remove(key: any): boolean {\r\n    return this._cache.remove(key) > 0;\r\n  }\r\n\r\n  /**\r\n   * Finds a resource in the cache by key\r\n   * @param key Key provided to identify the resource in the cache\r\n   *\r\n   * @returns The matching resource, if one exists\r\n  */\r\n  public find(key: any): any {\r\n    return this._cache.find(key)[0];\r\n  }\r\n\r\n  /**\r\n   * Checks if a resource exists in the cache by key\r\n   * @param key Key provided to identify the resource in the cache\r\n   *\r\n   * @returns Flag indicating if resource exists in the cache\r\n  */\r\n  public contains(key: any): boolean {\r\n    return this._cache.contains(key);\r\n  }\r\n\r\n  /**\r\n   * Remove all resources from the cache\r\n  */\r\n  public dump(): void {\r\n    this._cache.clear();\r\n  }\r\n\r\n  /**\r\n   * Get time to live in milliseconds for resources in cache\r\n   *\r\n   * @returns Time to live in milliseconds\r\n   */\r\n  public getCacheTtl(): number {\r\n    return this._appConfig.cacheTtl;\r\n  }\r\n}\r\n",
    "import { InjectionToken } from '@angular/core';\r\n\r\nexport interface CacheInterface {\r\n    add(key: any, value: any): void | boolean;\r\n    remove(key: any): void | boolean;\r\n    find(key: any): any;\r\n    contains(key: any): boolean;\r\n    dump(): void;\r\n    getCacheTtl(): number;\r\n}\r\n\r\nexport const CACHE: InjectionToken<CacheInterface> = new InjectionToken<CacheInterface>('mechaCache');\r\n",
    "import { InjectionToken } from '@angular/core';\r\n\r\nexport interface AppConfigInterface {\r\n    cacheTtl: number;\r\n}\r\n\r\nexport const APP_CONFIG: InjectionToken<AppConfigInterface> = new InjectionToken<AppConfigInterface>('mechaAppConfig');\r\n"
  ],
  "names": [
    "Immutable\n                .fromJS",
    "Immutable\n            .fromJS",
    "molar.Lookup"
  ],
  "mappings": "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"
}
