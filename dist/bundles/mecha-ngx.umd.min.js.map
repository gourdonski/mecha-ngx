{
  "version": 3,
  "file": "mecha-ngx.umd.min.js",
  "sources": [
    "ng://mecha-ngx/out/src/app/abstract/cache.abstract.ts",
    "ng://mecha-ngx/out/src/app/shared/services/mecha-cache/mecha-cache.service.ts",
    "ng://mecha-ngx/out/src/app/http/models/mecha-http-response.model.ts",
    "ng://mecha-ngx/out/src/app/shared/services/mecha-util/mecha-util.service.ts",
    "ng://mecha-ngx/out/src/app/http/services/mecha-http/mecha-http.service.ts",
    "ng://mecha-ngx/out/src/app/mecha.module.ts"
  ],
  "sourcesContent": [
    "import { InjectionToken } from '@angular/core';\r\n\r\nexport interface CacheInterface {\r\n    add(key: any, value: any): void | boolean;\r\n    remove(key: any): void | boolean;\r\n    find(key: any): any;\r\n    contains(key: any): boolean;\r\n    dump(): void;\r\n    getCacheTtl(): number;\r\n}\r\n\r\nexport const CACHE: InjectionToken<CacheInterface> = new InjectionToken<CacheInterface>('mechaCache');\r\n",
    "import { Inject, Injectable } from '@angular/core';\r\n\r\nimport * as molar from 'molar';\r\n\r\nimport { APP_CONFIG, AppConfigInterface } from '../../../abstract/app-config.abstract';\r\nimport { CacheInterface } from '../../../abstract/cache.abstract';\r\n\r\n@Injectable()\r\nexport class MechaCacheService implements CacheInterface {\r\n  // using a simple caching library that checks for expiration on retrieval\r\n  private _cache: molar.ILookup;\r\n\r\n  constructor(@Inject(APP_CONFIG) private readonly _appConfig: AppConfigInterface) {\r\n    this._cache = new molar.Lookup(false, _appConfig.cacheTtl);\r\n  }\r\n\r\n  /**\r\n   * Adds a resource to the cache using a key\r\n   * @param key Key provided to identify the resource in the cache\r\n   * @param value Value for the resource in the cache\r\n   *\r\n   * @returns Flag indicating if resource was successfully added\r\n  */\r\n  public add(key: any, value: any): boolean {\r\n    return this._cache.add(key, value);\r\n  }\r\n\r\n  /**\r\n   * Removes a resource from the cache by key\r\n   * @param key Key provided to identify the resource in the cache\r\n   *\r\n   * @returns Flag indicating if removal was successful\r\n  */\r\n  public remove(key: any): boolean {\r\n    return this._cache.remove(key) > 0;\r\n  }\r\n\r\n  /**\r\n   * Finds a resource in the cache by key\r\n   * @param key Key provided to identify the resource in the cache\r\n   *\r\n   * @returns The matching resource, if one exists\r\n  */\r\n  public find(key: any): any {\r\n    return this._cache.find(key)[0];\r\n  }\r\n\r\n  /**\r\n   * Checks if a resource exists in the cache by key\r\n   * @param key Key provided to identify the resource in the cache\r\n   *\r\n   * @returns Flag indicating if resource exists in the cache\r\n  */\r\n  public contains(key: any): boolean {\r\n    return this._cache.contains(key);\r\n  }\r\n\r\n  /**\r\n   * Remove all resources from the cache\r\n  */\r\n  public dump(): void {\r\n    this._cache.clear();\r\n  }\r\n\r\n  /**\r\n   * Get time to live in milliseconds for resources in cache\r\n   *\r\n   * @returns Time to live in milliseconds\r\n   */\r\n  public getCacheTtl(): number {\r\n    return this._appConfig.cacheTtl;\r\n  }\r\n}\r\n",
    "export class MechaHttpResponse<T> {\r\n  public requester: string;\r\n  public requestNumber: number;\r\n  public lastRequestTimestamp: Date | number;\r\n  public data: T;\r\n\r\n  constructor({\r\n    requester,\r\n    requestNumber = 1,\r\n    lastRequestTimestamp = new Date(),\r\n    data,\r\n  }: MechaHttpResponseInterface<T>) {\r\n    this.requester = requester;\r\n    this.requestNumber = requestNumber;\r\n    this.lastRequestTimestamp = lastRequestTimestamp;\r\n    this.data = data;\r\n  }\r\n}\r\n\r\nexport interface MechaHttpResponseInterface<T> {\r\n  requester: string;\r\n  requestNumber: number;\r\n  lastRequestTimestamp?: Date | number;\r\n  data: T;\r\n}\r\n",
    "import { Injectable } from '@angular/core';\n\n@Injectable()\nexport class MechaUtilService {\n  // http://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/\n  /**\n   * Converts a string to a hash code\n   * @param val Value to be hashed\n   *\n   * @returns Hash code generated from input value\n  */\n  public getHashCode(val: any): number {\n    if (!(typeof val === 'string' || val instanceof String)) {\n      return null;\n    }\n\n    let hash = 0;\n\n    let chr;\n\n    if (val.length === 0) {\n      return hash;\n    }\n\n    for (let i = 0; i < val.length; i++) {\n      chr = val.charCodeAt(i);\n      // tslint:disable-next-line:no-bitwise\n      hash = ((hash << 5) - hash) + chr;\n      // tslint:disable-next-line:no-bitwise\n      hash |= 0; // convert to 32-bit integer\n    }\n\n    return hash;\n  }\n}\n",
    "import { Inject, Injectable } from '@angular/core';\nimport { HttpClient, HttpResponse } from '@angular/common/http';\n\nimport * as Immutable from 'immutable';\nimport { AsyncSubject } from 'rxjs/AsyncSubject';\nimport { Observable } from 'rxjs/Observable';\nimport { ReplaySubject } from 'rxjs/ReplaySubject';\nimport { Subject } from 'rxjs/Subject';\nimport 'rxjs/add/observable/interval';\nimport 'rxjs/add/observable/throw';\nimport 'rxjs/add/operator/catch';\nimport 'rxjs/add/operator/debounceTime';\nimport 'rxjs/add/operator/finally';\nimport 'rxjs/add/operator/map';\nimport 'rxjs/add/operator/share';\nimport 'rxjs/add/operator/switchMap';\nimport 'rxjs/add/operator/take';\nimport 'rxjs/add/operator/takeUntil';\n\nimport { APP_CONFIG, AppConfigInterface } from '../../../abstract/app-config.abstract';\nimport { CACHE, CacheInterface } from '../../../abstract/cache.abstract';\nimport { MechaHttpResponse, MechaHttpResponseInterface } from '../../models/mecha-http-response.model';\nimport { MechaUtilService } from '../../../shared/services/mecha-util/mecha-util.service';\n\ninterface RequestNumberInterface { requestNumber: number; }\n\nconst ARBITRARY_TOKEN_VALUE = ' ';\n\n@Injectable()\nexport class MechaHttpService {\n  private _requestLookup: { [key: string]: Subject<any>} = {};\n\n  private _requesterHistory: { [key: string]: RequestNumberInterface } = {};\n\n  private _isDebouncingRequest = false;\n\n  private _debouncedSource: AsyncSubject<MechaHttpResponseInterface<any>>;\n\n  private _cachedSource: AsyncSubject<MechaHttpResponseInterface<any>>;\n\n  private _cachedImmutableSource: AsyncSubject<MechaHttpResponseInterface<any>>;\n\n  constructor(\n    @Inject(APP_CONFIG) private readonly _appConfig: AppConfigInterface,\n    @Inject(CACHE) private readonly _cache: CacheInterface,\n    private readonly _http: HttpClient,\n    private readonly _util: MechaUtilService) { }\n\n  /**\n   * Vanilla get request\n   * @param url URL to get resource from\n   *\n   * @returns The response as an observable\n  */\n  public get<T>(url: string): Observable<MechaHttpResponseInterface<T>> {\n    const requester = 'get';\n\n    return this._http\n      .get(url)\n      .catch(this.handleResponseError)\n      .map((response: HttpResponse<T>) => new MechaHttpResponse<T>({\n        requester: requester,\n        requestNumber: this.getRequestNumber(requester),\n        data: this.getResponseJson<T>(response),\n      }));\n  }\n\n  /**\n   * Share a single request amongst subscribers\n   * @param url URL to get resource from\n   *\n   * @returns The shared response as an observable\n  */\n  public getShared<T>(url: string): Observable<MechaHttpResponseInterface<T>> {\n    const requester = 'getShared';\n\n    return this._http\n      .get(url)\n      .catch(this.handleResponseError)\n      .map((response: HttpResponse<T>) => new MechaHttpResponse<T>({\n        requester: requester,\n        requestNumber: this.getRequestNumber(requester),\n        data: this.getResponseJson<T>(response),\n      }))\n      .share();\n  }\n\n  /**\n   * Thwart spammers with a debounced get\n   * @param url URL to get resource from\n   * @param [debounceInMilliseconds=1000] Length of time to debounce before submitting request\n   *\n   * @returns The debounced response as an observable\n  */\n  public getDebounced<T>(url: string, debounceInMilliseconds: number = 1000): Observable<MechaHttpResponseInterface<T>> {\n    const requester = 'getDebounced';\n\n    if (!this._isDebouncingRequest) {\n      this._debouncedSource = new AsyncSubject();\n\n      // not using switchMap because we don't want to hit backend at all until debounce completes\n      this._http.get(url)\n        .takeUntil(this._debouncedSource)\n        .debounceTime(debounceInMilliseconds)\n        .catch(this.handleResponseError)\n        .map((response: HttpResponse<T>) => new MechaHttpResponse<T>({\n          requester: requester,\n          requestNumber: this.getRequestNumber(requester),\n          data: this.getResponseJson<T>(response),\n        }))\n        .finally(() => this._isDebouncingRequest = false)\n        .subscribe(this._debouncedSource);\n    }\n\n    this._isDebouncingRequest = true;\n\n    return this._debouncedSource;\n  }\n\n /**\n   * Get responses until a condition is met, just because\n   * @param url URL to get resource from\n   * @param cancelToken Token used to cancel the interval\n   * @param [intervalInMilliseconds=1000] Length of time for each interval\n   * @param [numberOfIntervals] Number of times to execute request\n   *\n   * @returns The response in intervals as an observable\n  */\n  public getUntil<T>(url: string, cancelToken: Subject<void>, intervalInMilliseconds: number = 1000, numberOfIntervals?: number):\n    Observable<MechaHttpResponseInterface<T>> {\n    const requester = 'getUntil';\n\n    let getUntil$: Observable<number> = Observable\n      .interval(intervalInMilliseconds)\n      .takeUntil(cancelToken);\n\n    if (numberOfIntervals) {\n      getUntil$ = getUntil$.take(numberOfIntervals);\n    }\n\n    return getUntil$\n      .switchMap(() => this._http.get(url))\n      .catch(this.handleResponseError)\n      .map((response: HttpResponse<T>) => new MechaHttpResponse<T>({\n        requester: requester,\n        requestNumber: this.getRequestNumber(requester),\n        data: this.getResponseJson<T>(response),\n      }))\n      .share();\n  }\n\n  /**\n   * Make sure nothing is messing with your response\n   * @param url URL to get resource from\n   *\n   * @returns The response shared immutably as an observable\n  */\n  public getImmutable<T>(url: string): Observable<MechaHttpResponseInterface<T>> {\n    const requester = 'getImmutable';\n\n    return this._http\n      .get(url)\n      .catch(this.handleResponseError)\n      .map((response: HttpResponse<T>) => Immutable\n        .fromJS(new MechaHttpResponse<T>({\n          requester: requester,\n          requestNumber: this.getRequestNumber(requester),\n          data: this.getResponseJson<T>(response),\n        })))\n      .share()\n      .map((immutable: any) => immutable.toJS());\n  }\n\n  /**\n   * Cache a response to save trips to the backend\n   * @param url URL to get resource from\n   *\n   * @returns The cached response as an observable\n  */\n  public getCached<T>(url: string): Observable<MechaHttpResponseInterface<T>> {\n    const requester = 'getCached';\n\n    const key: number = this._util.getHashCode(url); // hashing URL and using as key in cache\n\n    const token: string = this._cache.find(key);\n\n    // if initial call or cache is expired, make fetch\n    if (token == null) {\n      this._cache.add(key, ARBITRARY_TOKEN_VALUE);\n\n      // clean up existing subject before re-initializing\n      if (this._cachedSource != null) {\n        this._cachedSource.complete();\n      }\n\n      this._cachedSource = new AsyncSubject();\n\n      this._http\n        .get(url)\n        .catch(this.handleResponseError)\n        .map((response: HttpResponse<T>) => new MechaHttpResponse<T>({\n          requester: requester,\n          requestNumber: this.getRequestNumber(requester),\n          data: this.getResponseJson<T>(response),\n        }))\n        .subscribe(this._cachedSource);\n    }\n\n    return this._cachedSource;\n  }\n\n  /**\n   * Cache a response to save trips to the backend and pass immutable copy to subscribers so they don't mess with each other\n   * @param url URL to get resource from\n   *\n   * @returns The cached response shared immutably as an observable\n  */\n  public getCachedImmutable<T>(url: string): Observable<MechaHttpResponseInterface<T>> {\n    const requester = 'getCachedImmutable';\n\n    const key: number = this._util.getHashCode(`immutable${url}`); // hashing URL and using as key in cache\n\n    const token: string = this._cache.find(key);\n\n    // if initial call or cache is expired, make fetch\n    if (token == null) {\n      this._cache.add(key, ARBITRARY_TOKEN_VALUE);\n\n      // clean up existing subject before re-initializing\n      if (this._cachedImmutableSource != null) {\n        this._cachedImmutableSource.complete();\n      }\n\n      this._cachedImmutableSource = new AsyncSubject();\n\n      this._http\n        .get(url)\n        .catch(this.handleResponseError)\n        .map((response: HttpResponse<T>) => Immutable\n          .fromJS(new MechaHttpResponse<T>({\n            requester: requester,\n            requestNumber: this.getRequestNumber(requester),\n            data: this.getResponseJson<T>(response),\n          })))\n        .subscribe(this._cachedImmutableSource);\n    }\n\n    return this._cachedImmutableSource.map((immutable: any) => immutable.toJS());\n  }\n\n  private getRequestNumber(requester: string): number {\n    return ++(this._requesterHistory[requester] = this._requesterHistory[requester] || { requestNumber: 0 }).requestNumber;\n  }\n\n  // the following are based on the Angular Http service doc\n  private getResponseJson<T>(response: HttpResponse<T>): T {\n    return response.body;\n  }\n\n  private handleResponseError(error: any): Observable<string> {\n    let errorMessage: string;\n\n    if (error instanceof HttpResponse) {\n      const json = error.body;\n\n      const err = json.error || JSON.stringify(json);\n\n      errorMessage = `${error.status}${error.statusText ? ' ' + error.statusText : ''} - ${err}`;\n    } else { errorMessage = error.message ? error.message : error.toString(); }\n\n    return Observable.throw(errorMessage);\n  }\n}\n",
    "import { BrowserModule } from '@angular/platform-browser';\nimport { ModuleWithProviders, NgModule } from '@angular/core';\nimport { HttpClientModule } from '@angular/common/http';\n\nimport { APP_CONFIG, AppConfigInterface } from './abstract/app-config.abstract';\nimport { CACHE, CacheInterface } from './abstract/cache.abstract';\nimport { MechaCacheService } from './shared/services/mecha-cache/mecha-cache.service';\nimport { MechaHttpService } from './http/services/mecha-http/mecha-http.service';\nimport { MechaUtilService } from './shared/services/mecha-util/mecha-util.service';\n\nconst defaultConfig: AppConfigInterface = {\n  cacheTtl: 60000,\n};\n\nexport interface MechaModuleOptionsInterface {\n  appConfig?: AppConfigInterface;\n  cacheClass?: new (...args: any[]) => CacheInterface;\n}\n\n@NgModule({\n  imports: [\n    BrowserModule,\n    HttpClientModule,\n  ],\n  providers: [\n    MechaHttpService,\n    MechaUtilService,\n  ],\n})\nexport class MechaModule {\n  static forRoot({\n      appConfig = defaultConfig,\n      cacheClass = MechaCacheService,\n    }: MechaModuleOptionsInterface): ModuleWithProviders {\n    return {\n      ngModule: MechaModule,\n      providers: [\n        { provide: APP_CONFIG, useValue: appConfig },\n        { provide: CACHE, useClass: cacheClass },\n      ]\n    };\n  }\n}\n"
  ],
  "names": [
    "CACHE",
    "InjectionToken",
    "this",
    "_appConfig",
    "MechaCacheService",
    "decorators",
    "type",
    "Injectable",
    "undefined",
    "Inject",
    "args",
    "APP_CONFIG",
    "requester",
    "_a",
    "_b",
    "requestNumber",
    "_c",
    "lastRequestTimestamp",
    "Date",
    "data",
    "hash",
    "val",
    "length",
    "i",
    "charCodeAt",
    "MechaUtilService",
    "_cache",
    "_http",
    "_util",
    "_requestLookup",
    "_requesterHistory",
    "_isDebouncingRequest",
    "get",
    "url",
    "catch",
    "handleResponseError",
    "map",
    "response",
    "MechaHttpResponse",
    "_this",
    "getRequestNumber",
    "getResponseJson",
    "share",
    "MechaHttpService",
    "prototype",
    "getDebounced",
    "debounceInMilliseconds",
    "_debouncedSource",
    "AsyncSubject",
    "takeUntil",
    "debounceTime",
    "finally",
    "subscribe",
    "getUntil",
    "cancelToken",
    "intervalInMilliseconds",
    "numberOfIntervals",
    "getUntil$",
    "Observable",
    "interval",
    "take",
    "switchMap",
    "getImmutable",
    "fromJS",
    "getCached",
    "key",
    "getHashCode",
    "find",
    "add",
    "_cachedSource",
    "complete",
    "getCachedImmutable",
    "_cachedImmutableSource",
    "immutable",
    "toJS",
    "body",
    "error",
    "errorMessage",
    "HttpResponse",
    "json",
    "HttpClient",
    "defaultConfig",
    "MechaModule",
    "forRoot",
    "ngModule",
    "providers",
    "provide",
    "useValue",
    "appConfig",
    "useClass"
  ],
  "mappings": "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"
}
