{
  "version": 3,
  "file": "mecha-ngx.umd.min.js",
  "sources": [
    "ng://mecha-ngx/out/src/app/abstract/cache.abstract.ts",
    "ng://mecha-ngx/out/src/app/shared/services/mecha-cache/mecha-cache.service.ts",
    "ng://mecha-ngx/out/src/app/http/models/mecha-http-response.model.ts",
    "ng://mecha-ngx/out/src/app/shared/services/mecha-util/mecha-util.service.ts",
    "ng://mecha-ngx/out/src/app/http/services/mecha-http/mecha-http.service.ts",
    "ng://mecha-ngx/out/src/app/mecha.module.ts"
  ],
  "sourcesContent": [
    "import { InjectionToken } from '@angular/core';\r\n\r\nexport interface CacheInterface {\r\n    add(key: any, value: any): void | boolean;\r\n    remove(key: any): void | boolean;\r\n    find(key: any): any;\r\n    contains(key: any): boolean;\r\n    dump(): void;\r\n    getCacheTtl(): number;\r\n}\r\n\r\nexport const CACHE: InjectionToken<CacheInterface> = new InjectionToken<CacheInterface>('mechaCache');\r\n",
    "import { Inject, Injectable } from '@angular/core';\r\n\r\nimport * as molar from 'molar';\r\n\r\nimport { APP_CONFIG, AppConfigInterface } from '../../../abstract/app-config.abstract';\r\nimport { CacheInterface } from '../../../abstract/cache.abstract';\r\n\r\n@Injectable()\r\nexport class MechaCacheService implements CacheInterface {\r\n  // using a simple caching library that checks for expiration on retrieval\r\n  private _cache: molar.ILookup;\r\n\r\n  constructor(@Inject(APP_CONFIG) private readonly _appConfig: AppConfigInterface) {\r\n    this._cache = new molar.Lookup(false, _appConfig.cacheTtl);\r\n  }\r\n\r\n  /**\r\n   * Adds a resource to the cache using a key\r\n   * @param key Key provided to identify the resource in the cache\r\n   * @param value Value for the resource in the cache\r\n   *\r\n   * @returns Flag indicating if resource was successfully added\r\n  */\r\n  public add(key: any, value: any): boolean {\r\n    return this._cache.add(key, value);\r\n  }\r\n\r\n  /**\r\n   * Removes a resource from the cache by key\r\n   * @param key Key provided to identify the resource in the cache\r\n   *\r\n   * @returns Flag indicating if removal was successful\r\n  */\r\n  public remove(key: any): boolean {\r\n    return this._cache.remove(key) > 0;\r\n  }\r\n\r\n  /**\r\n   * Finds a resource in the cache by key\r\n   * @param key Key provided to identify the resource in the cache\r\n   *\r\n   * @returns The matching resource, if one exists\r\n  */\r\n  public find(key: any): any {\r\n    return this._cache.find(key)[0];\r\n  }\r\n\r\n  /**\r\n   * Checks if a resource exists in the cache by key\r\n   * @param key Key provided to identify the resource in the cache\r\n   *\r\n   * @returns Flag indicating if resource exists in the cache\r\n  */\r\n  public contains(key: any): boolean {\r\n    return this._cache.contains(key);\r\n  }\r\n\r\n  /**\r\n   * Remove all resources from the cache\r\n  */\r\n  public dump(): void {\r\n    this._cache.clear();\r\n  }\r\n\r\n  /**\r\n   * Get time to live in milliseconds for resources in cache\r\n   *\r\n   * @returns Time to live in milliseconds\r\n   */\r\n  public getCacheTtl(): number {\r\n    return this._appConfig.cacheTtl;\r\n  }\r\n}\r\n",
    "export class MechaHttpResponse<T> {\r\n  public requester: string;\r\n  public requestNumber: number;\r\n  public lastRequestTimestamp: Date | number;\r\n  public data: T;\r\n\r\n  constructor({\r\n    requester,\r\n    requestNumber = 1,\r\n    lastRequestTimestamp = new Date(),\r\n    data,\r\n  }: MechaHttpResponseInterface<T>) {\r\n    this.requester = requester;\r\n    this.requestNumber = requestNumber;\r\n    this.lastRequestTimestamp = lastRequestTimestamp;\r\n    this.data = data;\r\n  }\r\n}\r\n\r\nexport interface MechaHttpResponseInterface<T> {\r\n  requester: string;\r\n  requestNumber: number;\r\n  lastRequestTimestamp?: Date | number;\r\n  data: T;\r\n}\r\n",
    "import { Injectable } from '@angular/core';\n\n@Injectable()\nexport class MechaUtilService {\n  // http://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/\n  /**\n   * Converts a string to a hash code\n   * @param val Value to be hashed\n   *\n   * @returns Hash code generated from input value\n  */\n  public getHashCode(val: any): number {\n    if (!(typeof val === 'string' || val instanceof String)) {\n      return null;\n    }\n\n    let hash = 0;\n\n    let chr;\n\n    if (val.length === 0) {\n      return hash;\n    }\n\n    for (let i = 0; i < val.length; i++) {\n      chr = val.charCodeAt(i);\n      // tslint:disable-next-line:no-bitwise\n      hash = ((hash << 5) - hash) + chr;\n      // tslint:disable-next-line:no-bitwise\n      hash |= 0; // convert to 32-bit integer\n    }\n\n    return hash;\n  }\n}\n",
    "import { Inject, Injectable } from '@angular/core';\nimport { HttpClient, HttpResponse } from '@angular/common/http';\n\nimport * as Immutable from 'immutable';\nimport { AsyncSubject } from 'rxjs/AsyncSubject';\nimport { Observable } from 'rxjs/Observable';\nimport { ReplaySubject } from 'rxjs/ReplaySubject';\nimport { Subject } from 'rxjs/Subject';\nimport 'rxjs/add/observable/interval';\nimport 'rxjs/add/observable/throw';\nimport 'rxjs/add/operator/catch';\nimport 'rxjs/add/operator/debounceTime';\nimport 'rxjs/add/operator/finally';\nimport 'rxjs/add/operator/map';\nimport 'rxjs/add/operator/share';\nimport 'rxjs/add/operator/switchMap';\nimport 'rxjs/add/operator/take';\nimport 'rxjs/add/operator/takeUntil';\n\nimport { APP_CONFIG, AppConfigInterface } from '../../../abstract/app-config.abstract';\nimport { CACHE, CacheInterface } from '../../../abstract/cache.abstract';\nimport { MechaHttpResponse, MechaHttpResponseInterface } from '../../models/mecha-http-response.model';\nimport { MechaUtilService } from '../../../shared/services/mecha-util/mecha-util.service';\n\ninterface RequestNumberInterface { requestNumber: number; }\n\nconst ARBITRARY_TOKEN_VALUE = ' ';\n\n@Injectable()\nexport class MechaHttpService {\n  private _requestLookup: { [key: string]: Subject<any>} = {};\n\n  private _requesterHistory: { [key: string]: RequestNumberInterface } = {};\n\n  private _cachedSource: AsyncSubject<MechaHttpResponseInterface<any>>;\n\n  private _cachedImmutableSource: AsyncSubject<MechaHttpResponseInterface<any>>;\n\n  constructor(\n    @Inject(APP_CONFIG) private readonly _appConfig: AppConfigInterface,\n    @Inject(CACHE) private readonly _cache: CacheInterface,\n    private readonly _http: HttpClient,\n    private readonly _util: MechaUtilService) { }\n\n  /**\n   * Vanilla get request\n   * @param url URL to get resource from\n   *\n   * @returns The response as an observable\n  */\n  public get<T>(url: string): Observable<MechaHttpResponseInterface<T>> {\n    const requester = 'get';\n\n    return this._http\n      .get(url)\n      .catch(this.handleResponseError)\n      .map((response: HttpResponse<T>) => new MechaHttpResponse<T>({\n        requester: requester,\n        requestNumber: this.getRequestNumber(requester),\n        data: this.getResponseJson<T>(response),\n      }));\n  }\n\n  /**\n   * Share a single request amongst subscribers\n   * @param url URL to get resource from\n   *\n   * @returns The shared response as an observable\n  */\n  public getShared<T>(url: string): Observable<MechaHttpResponseInterface<T>> {\n    const requester = 'getShared';\n\n    return this._http\n      .get(url)\n      .catch(this.handleResponseError)\n      .map((response: HttpResponse<T>) => new MechaHttpResponse<T>({\n        requester: requester,\n        requestNumber: this.getRequestNumber(requester),\n        data: this.getResponseJson<T>(response),\n      }))\n      .share();\n  }\n\n  /**\n   * Thwart spammers with a debounced get\n   * @param url URL to get resource from\n   * @param requestSource Source subject for making requests\n   * @param [debounceInMilliseconds=1000] Length of time to debounce before submitting request\n   *\n   * @returns The debounced response as an observable\n  */\n  public getDebounced<T>(url: string, requestSource: Subject<any>, debounceInMilliseconds: number = 1000):\n    Observable<MechaHttpResponseInterface<T>> {\n    const requester = 'getDebounced';\n\n    return requestSource\n      .debounceTime(debounceInMilliseconds)\n      .switchMap(() => this._http.get(url))\n      .catch(this.handleResponseError)\n        .map((response: HttpResponse<T>) => new MechaHttpResponse<T>({\n          requester: requester,\n          requestNumber: this.getRequestNumber(requester),\n          data: this.getResponseJson<T>(response),\n        }));\n  }\n\n /**\n   * Get responses until a condition is met, just because\n   * @param url URL to get resource from\n   * @param cancelToken Token used to cancel the interval\n   * @param [intervalInMilliseconds=1000] Length of time for each interval\n   * @param [numberOfIntervals] Number of times to execute request\n   *\n   * @returns The response in intervals as an observable\n  */\n  public getUntil<T>(url: string, cancelToken: Subject<void>, intervalInMilliseconds: number = 1000, numberOfIntervals?: number):\n    Observable<MechaHttpResponseInterface<T>> {\n    const requester = 'getUntil';\n\n    let getUntil$: Observable<number> = Observable\n      .interval(intervalInMilliseconds)\n      .takeUntil(cancelToken);\n\n    if (numberOfIntervals) {\n      getUntil$ = getUntil$.take(numberOfIntervals);\n    }\n\n    return getUntil$\n      .switchMap(() => this._http.get(url))\n      .catch(this.handleResponseError)\n      .map((response: HttpResponse<T>) => new MechaHttpResponse<T>({\n        requester: requester,\n        requestNumber: this.getRequestNumber(requester),\n        data: this.getResponseJson<T>(response),\n      }))\n      .share();\n  }\n\n  /**\n   * Make sure nothing is messing with your response\n   * @param url URL to get resource from\n   *\n   * @returns The response shared immutably as an observable\n  */\n  public getImmutable<T>(url: string): Observable<MechaHttpResponseInterface<T>> {\n    const requester = 'getImmutable';\n\n    return this._http\n      .get(url)\n      .catch(this.handleResponseError)\n      .map((response: HttpResponse<T>) => Immutable\n        .fromJS(new MechaHttpResponse<T>({\n          requester: requester,\n          requestNumber: this.getRequestNumber(requester),\n          data: this.getResponseJson<T>(response),\n        })))\n      .share()\n      .map((immutable: any) => immutable.toJS());\n  }\n\n  /**\n   * Cache a response to save trips to the backend\n   * @param url URL to get resource from\n   *\n   * @returns The cached response as an observable\n  */\n  public getCached<T>(url: string): Observable<MechaHttpResponseInterface<T>> {\n    const requester = 'getCached';\n\n    const key: number = this._util.getHashCode(url); // hashing URL and using as key in cache\n\n    const token: string = this._cache.find(key);\n\n    // if initial call or cache is expired, make fetch\n    if (token == null) {\n      this._cache.add(key, ARBITRARY_TOKEN_VALUE);\n\n      // clean up existing subject before re-initializing\n      if (this._cachedSource != null) {\n        this._cachedSource.complete();\n      }\n\n      this._cachedSource = new AsyncSubject();\n\n      this._http\n        .get(url)\n        .catch(this.handleResponseError)\n        .map((response: HttpResponse<T>) => new MechaHttpResponse<T>({\n          requester: requester,\n          requestNumber: this.getRequestNumber(requester),\n          data: this.getResponseJson<T>(response),\n        }))\n        .subscribe(this._cachedSource);\n    }\n\n    return this._cachedSource;\n  }\n\n  /**\n   * Cache a response to save trips to the backend and pass immutable copy to subscribers so they don't mess with each other\n   * @param url URL to get resource from\n   *\n   * @returns The cached response shared immutably as an observable\n  */\n  public getCachedImmutable<T>(url: string): Observable<MechaHttpResponseInterface<T>> {\n    const requester = 'getCachedImmutable';\n\n    const key: number = this._util.getHashCode(`immutable${url}`); // hashing URL and using as key in cache\n\n    const token: string = this._cache.find(key);\n\n    // if initial call or cache is expired, make fetch\n    if (token == null) {\n      this._cache.add(key, ARBITRARY_TOKEN_VALUE);\n\n      // clean up existing subject before re-initializing\n      if (this._cachedImmutableSource != null) {\n        this._cachedImmutableSource.complete();\n      }\n\n      this._cachedImmutableSource = new AsyncSubject();\n\n      this._http\n        .get(url)\n        .catch(this.handleResponseError)\n        .map((response: HttpResponse<T>) => Immutable\n          .fromJS(new MechaHttpResponse<T>({\n            requester: requester,\n            requestNumber: this.getRequestNumber(requester),\n            data: this.getResponseJson<T>(response),\n          })))\n        .subscribe(this._cachedImmutableSource);\n    }\n\n    return this._cachedImmutableSource.map((immutable: any) => immutable.toJS());\n  }\n\n  private getRequestNumber(requester: string): number {\n    return ++(this._requesterHistory[requester] = this._requesterHistory[requester] || { requestNumber: 0 }).requestNumber;\n  }\n\n  // the following are based on the Angular Http service doc\n  private getResponseJson<T>(response: HttpResponse<T>): T {\n    return response.body;\n  }\n\n  private handleResponseError(error: any): Observable<string> {\n    let errorMessage: string;\n\n    if (error instanceof HttpResponse) {\n      const json = error.body;\n\n      const err = json.error || JSON.stringify(json);\n\n      errorMessage = `${error.status}${error.statusText ? ' ' + error.statusText : ''} - ${err}`;\n    } else { errorMessage = error.message ? error.message : error.toString(); }\n\n    return Observable.throw(errorMessage);\n  }\n}\n",
    "import { BrowserModule } from '@angular/platform-browser';\nimport { ModuleWithProviders, NgModule } from '@angular/core';\nimport { HttpClientModule } from '@angular/common/http';\n\nimport { APP_CONFIG, AppConfigInterface } from './abstract/app-config.abstract';\nimport { CACHE, CacheInterface } from './abstract/cache.abstract';\nimport { MechaCacheService } from './shared/services/mecha-cache/mecha-cache.service';\nimport { MechaHttpService } from './http/services/mecha-http/mecha-http.service';\nimport { MechaUtilService } from './shared/services/mecha-util/mecha-util.service';\n\nconst defaultConfig: AppConfigInterface = {\n  cacheTtl: 60000,\n};\n\nexport interface MechaModuleOptionsInterface {\n  appConfig?: AppConfigInterface;\n  cacheClass?: new (...args: any[]) => CacheInterface;\n}\n\n@NgModule({\n  imports: [\n    BrowserModule,\n    HttpClientModule,\n  ],\n  providers: [\n    MechaHttpService,\n    MechaUtilService,\n  ],\n})\nexport class MechaModule {\n  static forRoot({\n      appConfig = defaultConfig,\n      cacheClass = MechaCacheService,\n    }: MechaModuleOptionsInterface): ModuleWithProviders {\n    return {\n      ngModule: MechaModule,\n      providers: [\n        { provide: APP_CONFIG, useValue: appConfig },\n        { provide: CACHE, useClass: cacheClass },\n      ]\n    };\n  }\n}\n"
  ],
  "names": [
    "CACHE",
    "InjectionToken",
    "this",
    "_appConfig",
    "MechaCacheService",
    "decorators",
    "type",
    "Injectable",
    "undefined",
    "Inject",
    "args",
    "APP_CONFIG",
    "requester",
    "_a",
    "_b",
    "requestNumber",
    "_c",
    "lastRequestTimestamp",
    "Date",
    "data",
    "hash",
    "val",
    "length",
    "i",
    "charCodeAt",
    "MechaUtilService",
    "_cache",
    "_http",
    "_util",
    "_requestLookup",
    "_requesterHistory",
    "get",
    "url",
    "catch",
    "handleResponseError",
    "map",
    "response",
    "MechaHttpResponse",
    "_this",
    "getRequestNumber",
    "getResponseJson",
    "share",
    "MechaHttpService",
    "prototype",
    "getDebounced",
    "requestSource",
    "debounceInMilliseconds",
    "debounceTime",
    "switchMap",
    "getUntil",
    "cancelToken",
    "intervalInMilliseconds",
    "numberOfIntervals",
    "getUntil$",
    "Observable",
    "interval",
    "takeUntil",
    "take",
    "getImmutable",
    "fromJS",
    "getCached",
    "key",
    "getHashCode",
    "find",
    "add",
    "_cachedSource",
    "complete",
    "AsyncSubject",
    "getCachedImmutable",
    "_cachedImmutableSource",
    "immutable",
    "toJS",
    "body",
    "error",
    "errorMessage",
    "HttpResponse",
    "json",
    "HttpClient",
    "defaultConfig",
    "MechaModule",
    "forRoot",
    "ngModule",
    "providers",
    "provide",
    "useValue",
    "appConfig",
    "useClass"
  ],
  "mappings": "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"
}
