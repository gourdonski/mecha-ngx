{
  "version": 3,
  "file": "mecha-ngx.umd.min.js",
  "sources": [
    "ng://mecha-ngx/out/src/app/abstract/cache.abstract.ts",
    "ng://mecha-ngx/out/src/app/shared/services/mecha-cache/mecha-cache.service.ts",
    "ng://mecha-ngx/out/src/app/http/models/mecha-http-response.model.ts",
    "ng://mecha-ngx/out/src/app/shared/services/mecha-util/mecha-util.service.ts",
    "ng://mecha-ngx/out/src/app/http/services/mecha-http/mecha-http.service.ts",
    "ng://mecha-ngx/out/src/app/mecha.module.ts"
  ],
  "sourcesContent": [
    "import { InjectionToken } from '@angular/core';\r\n\r\nexport interface CacheInterface {\r\n    add(key: any, value: any, onDestroy?: () => void): void | boolean;\r\n    remove(key: any): void | boolean;\r\n    find(key: any): any;\r\n    contains(key: any): boolean;\r\n    dump(): void;\r\n    getCacheTtl(): number;\r\n}\r\n\r\nexport const CACHE: InjectionToken<CacheInterface> = new InjectionToken<CacheInterface>('mechaCache');\r\n",
    "import { Inject, Injectable } from '@angular/core';\r\n\r\nimport * as molar from 'molar';\r\n\r\nimport { APP_CONFIG, AppConfigInterface } from '../../../abstract/app-config.abstract';\r\nimport { CacheInterface } from '../../../abstract/cache.abstract';\r\n\r\n@Injectable()\r\nexport class MechaCacheService implements CacheInterface {\r\n  // using a simple caching library that checks for expiration on retrieval\r\n  private _cache: molar.ILookup;\r\n\r\n  constructor(@Inject(APP_CONFIG) private readonly _appConfig: AppConfigInterface) {\r\n    this._cache = new molar.Lookup(false, _appConfig.cacheTtl);\r\n  }\r\n\r\n  /**\r\n   * Adds a resource to the cache using a key\r\n   * @param key Key provided to identify the resource in the cache\r\n   * @param value Value for the resource in the cache\r\n   *\r\n   * @returns Flag indicating if resource was successfully added\r\n  */\r\n  public add(key: any, value: any, onDestroy?: () => void): boolean {\r\n    return this._cache.add(key, value, onDestroy);\r\n  }\r\n\r\n  /**\r\n   * Removes a resource from the cache by key\r\n   * @param key Key provided to identify the resource in the cache\r\n   *\r\n   * @returns Flag indicating if removal was successful\r\n  */\r\n  public remove(key: any): boolean {\r\n    return this._cache.remove(key) > 0;\r\n  }\r\n\r\n  /**\r\n   * Finds a resource in the cache by key\r\n   * @param key Key provided to identify the resource in the cache\r\n   *\r\n   * @returns The matching resource, if one exists\r\n  */\r\n  public find(key: any): any {\r\n    return this._cache.find(key)[0];\r\n  }\r\n\r\n  /**\r\n   * Checks if a resource exists in the cache by key\r\n   * @param key Key provided to identify the resource in the cache\r\n   *\r\n   * @returns Flag indicating if resource exists in the cache\r\n  */\r\n  public contains(key: any): boolean {\r\n    return this._cache.contains(key);\r\n  }\r\n\r\n  /**\r\n   * Remove all resources from the cache\r\n  */\r\n  public dump(): void {\r\n    this._cache.clear();\r\n  }\r\n\r\n  /**\r\n   * Get time to live in milliseconds for resources in cache\r\n   *\r\n   * @returns Time to live in milliseconds\r\n   */\r\n  public getCacheTtl(): number {\r\n    return this._appConfig.cacheTtl;\r\n  }\r\n}\r\n",
    "export class MechaHttpResponse<T> {\r\n  public requester: string;\r\n  public requestNumber: number;\r\n  public lastRequestTimestamp: Date | number;\r\n  public data: T;\r\n\r\n  constructor({\r\n    requester,\r\n    requestNumber = 1,\r\n    lastRequestTimestamp = new Date(),\r\n    data,\r\n  }: MechaHttpResponseInterface<T>) {\r\n    this.requester = requester;\r\n    this.requestNumber = requestNumber;\r\n    this.lastRequestTimestamp = lastRequestTimestamp;\r\n    this.data = data;\r\n  }\r\n}\r\n\r\nexport interface MechaHttpResponseInterface<T> {\r\n  requester: string;\r\n  requestNumber: number;\r\n  lastRequestTimestamp?: Date | number;\r\n  data: T;\r\n}\r\n",
    "import { Injectable } from '@angular/core';\n\n@Injectable()\nexport class MechaUtilService {\n  // http://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/\n  /**\n   * Converts a string to a hash code\n   * @param val Value to be hashed\n   *\n   * @returns Hash code generated from input value\n  */\n  public getHashCode(val: any): number {\n    if (!(typeof val === 'string' || val instanceof String)) {\n      return null;\n    }\n\n    let hash = 0;\n\n    let chr;\n\n    if (val.length === 0) {\n      return hash;\n    }\n\n    for (let i = 0; i < val.length; i++) {\n      chr = val.charCodeAt(i);\n      // tslint:disable-next-line:no-bitwise\n      hash = ((hash << 5) - hash) + chr;\n      // tslint:disable-next-line:no-bitwise\n      hash |= 0; // convert to 32-bit integer\n    }\n\n    return hash;\n  }\n}\n",
    "import { Inject, Injectable } from '@angular/core';\nimport { HttpClient, HttpResponse } from '@angular/common/http';\n\nimport * as Immutable from 'immutable';\nimport { AsyncSubject } from 'rxjs/AsyncSubject';\nimport { Observable } from 'rxjs/Observable';\nimport { ReplaySubject } from 'rxjs/ReplaySubject';\nimport { Subject } from 'rxjs/Subject';\nimport 'rxjs/add/observable/interval';\nimport 'rxjs/add/observable/throw';\nimport 'rxjs/add/operator/catch';\nimport 'rxjs/add/operator/debounceTime';\nimport 'rxjs/add/operator/finally';\nimport 'rxjs/add/operator/map';\nimport 'rxjs/add/operator/share';\nimport 'rxjs/add/operator/switchMap';\nimport 'rxjs/add/operator/take';\nimport 'rxjs/add/operator/takeUntil';\n\nimport { APP_CONFIG, AppConfigInterface } from '../../../abstract/app-config.abstract';\nimport { CACHE, CacheInterface } from '../../../abstract/cache.abstract';\nimport { MechaHttpResponse, MechaHttpResponseInterface } from '../../models/mecha-http-response.model';\nimport { MechaUtilService } from '../../../shared/services/mecha-util/mecha-util.service';\n\ninterface RequestNumberInterface { requestNumber: number; }\n\n@Injectable()\nexport class MechaHttpService {\n  private _requesterHistory: { [key: string]: RequestNumberInterface } = {};\n\n  constructor(\n    @Inject(APP_CONFIG) private readonly _appConfig: AppConfigInterface,\n    @Inject(CACHE) private readonly _cache: CacheInterface,\n    private readonly _http: HttpClient,\n    private readonly _util: MechaUtilService) { }\n\n  /**\n   * Vanilla get request\n   * @param url URL to get resource from\n   *\n   * @returns The response as an observable\n  */\n  public get<T>(url: string): Observable<MechaHttpResponseInterface<T>> {\n    const requester = 'get';\n\n    return this._http\n      .get(url)\n      .catch(this.handleResponseError)\n      .map((response: HttpResponse<T>) => new MechaHttpResponse<T>({\n        requester: requester,\n        requestNumber: this.getRequestNumber(requester),\n        data: this.getResponseJson<T>(response),\n      }));\n  }\n\n  /**\n   * Share a single request amongst subscribers\n   * @param url URL to get resource from\n   *\n   * @returns The shared response as an observable\n  */\n  public getShared<T>(url: string): Observable<MechaHttpResponseInterface<T>> {\n    const requester = 'getShared';\n\n    return this._http\n      .get(url)\n      .catch(this.handleResponseError)\n      .map((response: HttpResponse<T>) => new MechaHttpResponse<T>({\n        requester: requester,\n        requestNumber: this.getRequestNumber(requester),\n        data: this.getResponseJson<T>(response),\n      }))\n      .share();\n  }\n\n  /**\n   * Thwart spammers with a debounced get\n   * @param url URL to get resource from\n   * @param requestSource Source subject for making requests\n   * @param [debounceInMilliseconds=1000] Length of time to debounce before submitting request\n   *\n   * @returns The debounced response as an observable\n  */\n  public getDebounced<T>(url: string, requestSource: Subject<any>, debounceInMilliseconds: number = 1000):\n    Observable<MechaHttpResponseInterface<T>> {\n    const requester = 'getDebounced';\n\n    return requestSource\n      .debounceTime(debounceInMilliseconds)\n      .switchMap(() => this._http.get(url))\n      .catch(this.handleResponseError)\n      .map((response: HttpResponse<T>) => new MechaHttpResponse<T>({\n        requester: requester,\n        requestNumber: this.getRequestNumber(requester),\n        data: this.getResponseJson<T>(response),\n      }))\n      .share();\n  }\n\n /**\n   * Get responses until a condition is met, just because\n   * @param url URL to get resource from\n   * @param cancelToken Token used to cancel the interval\n   * @param [intervalInMilliseconds=1000] Length of time for each interval\n   * @param [numberOfIntervals] Number of times to execute request\n   *\n   * @returns The response in intervals as an observable\n  */\n  public getUntil<T>(url: string, cancelToken: Subject<void>, intervalInMilliseconds: number = 1000, numberOfIntervals?: number):\n    Observable<MechaHttpResponseInterface<T>> {\n    const requester = 'getUntil';\n\n    let getUntil$: Observable<number> = Observable\n      .interval(intervalInMilliseconds)\n      .takeUntil(cancelToken);\n\n    if (numberOfIntervals != null) {\n      getUntil$ = getUntil$.take(numberOfIntervals);\n    }\n\n    return getUntil$\n      .switchMap(() => this._http.get(url))\n      .catch(this.handleResponseError)\n      .map((response: HttpResponse<T>) => new MechaHttpResponse<T>({\n        requester: requester,\n        requestNumber: this.getRequestNumber(requester),\n        data: this.getResponseJson<T>(response),\n      }))\n      .share();\n  }\n\n  /**\n   * Make sure nothing is messing with your response\n   * @param url URL to get resource from\n   *\n   * @returns The response shared immutably as an observable\n  */\n  public getImmutable<T>(url: string): Observable<MechaHttpResponseInterface<T>> {\n    const requester = 'getImmutable';\n\n    return this._http\n      .get(url)\n      .catch(this.handleResponseError)\n      .map((response: HttpResponse<T>) => Immutable\n        .fromJS(new MechaHttpResponse<T>({\n          requester: requester,\n          requestNumber: this.getRequestNumber(requester),\n          data: this.getResponseJson<T>(response),\n        })))\n      .share()\n      .map((immutable: any) => immutable.toJS());\n  }\n\n  /**\n   * Cache a response to save trips to the backend\n   * @param url URL to get resource from\n   *\n   * @returns The cached response as an observable\n  */\n  public getCached<T>(url: string): Observable<MechaHttpResponseInterface<T>> {\n    try {\n      const requester = 'getCached';\n\n      const key: number = this._util.getHashCode(url); // hashing URL and using as key in cache\n\n      let cachedSource: AsyncSubject<MechaHttpResponseInterface<T>> = this._cache.find(key);\n\n      // if initial call or cache is expired, make fetch\n      if (cachedSource == null) {\n        cachedSource = new AsyncSubject();\n\n        this._cache.add(key, cachedSource, () => cachedSource.complete());\n\n        this._http\n          .get(url)\n          .catch(this.handleResponseError)\n          .map((response: HttpResponse<T>) => new MechaHttpResponse<T>({\n            requester: requester,\n            requestNumber: this.getRequestNumber(requester),\n            data: this.getResponseJson<T>(response),\n          }))\n          .subscribe(cachedSource);\n      }\n\n      return cachedSource.asObservable();\n    } catch (err) {\n      return Observable.throw(err);\n    }\n  }\n\n  /**\n   * Cache a response to save trips to the backend and pass immutable copy to subscribers so they don't mess with each other\n   * @param url URL to get resource from\n   *\n   * @returns The cached response shared immutably as an observable\n  */\n  public getCachedImmutable<T>(url: string): Observable<MechaHttpResponseInterface<T>> {\n    try {\n      const requester = 'getCachedImmutable';\n\n      const key: number = this._util.getHashCode(`immutable${url}`); // hashing URL and using as key in cache\n\n      let cachedImmutableSource: AsyncSubject<MechaHttpResponseInterface<T>> = this._cache.find(key);\n\n      // if initial call or cache is expired, make fetch\n      if (cachedImmutableSource == null) {\n        cachedImmutableSource = new AsyncSubject();\n\n        this._cache.add(key, cachedImmutableSource, () => cachedImmutableSource.complete());\n\n        this._http\n          .get(url)\n          .catch(this.handleResponseError)\n          .map((response: HttpResponse<T>) => Immutable\n            .fromJS(new MechaHttpResponse<T>({\n              requester: requester,\n              requestNumber: this.getRequestNumber(requester),\n              data: this.getResponseJson<T>(response),\n            })))\n          .subscribe(cachedImmutableSource);\n      }\n\n      return cachedImmutableSource.map((immutable: any) => immutable.toJS());\n    } catch (err) {\n      return Observable.throw(err);\n    }\n  }\n\n  private getRequestNumber(requester: string): number {\n    return ++(this._requesterHistory[requester] = this._requesterHistory[requester] || { requestNumber: 0 }).requestNumber;\n  }\n\n  // the following are based on the Angular Http service doc\n  private getResponseJson<T>(response: HttpResponse<T>): T {\n    try {\n      return response.body;\n    } catch (err) {\n      return err;\n    }\n  }\n\n  private handleResponseError(error: any): Observable<string> {\n    let errorMessage: string;\n\n    if (error instanceof HttpResponse) {\n      const json = error.body;\n\n      const err = json.error || JSON.stringify(json);\n\n      errorMessage = this.formatError(error.status, error.statusText, err);\n    } else { errorMessage = error.message ? error.message : error.toString(); }\n\n    return Observable.throw(errorMessage);\n  }\n\n  private formatError = (errorStatus: number | string, errorStatusText?: string, errorMessage?: string): string =>\n    `${errorStatus}${errorStatusText == null ? '' : ' ' + errorStatusText}${errorMessage == null ? '' : ' - ' + errorMessage}`\n}\n",
    "import { BrowserModule } from '@angular/platform-browser';\nimport { ModuleWithProviders, NgModule } from '@angular/core';\nimport { HttpClientModule } from '@angular/common/http';\n\nimport { APP_CONFIG, AppConfigInterface } from './abstract/app-config.abstract';\nimport { CACHE, CacheInterface } from './abstract/cache.abstract';\nimport { MechaCacheService } from './shared/services/mecha-cache/mecha-cache.service';\nimport { MechaHttpService } from './http/services/mecha-http/mecha-http.service';\nimport { MechaUtilService } from './shared/services/mecha-util/mecha-util.service';\n\nconst defaultConfig: AppConfigInterface = {\n  cacheTtl: 60000,\n};\n\nexport interface MechaModuleOptionsInterface {\n  appConfig?: AppConfigInterface;\n  cacheClass?: new (...args: any[]) => CacheInterface;\n}\n\n@NgModule({\n  imports: [\n    BrowserModule,\n    HttpClientModule,\n  ],\n  providers: [\n    MechaCacheService,\n    MechaHttpService,\n    MechaUtilService,\n  ],\n})\nexport class MechaModule {\n  static forRoot({\n      appConfig,\n      cacheClass,\n    }: MechaModuleOptionsInterface): ModuleWithProviders {\n    return {\n      ngModule: MechaModule,\n      providers: [\n        { provide: APP_CONFIG, useValue: appConfig || defaultConfig },\n        { provide: CACHE, useClass: cacheClass || MechaCacheService },\n      ]\n    };\n  }\n}\n"
  ],
  "names": [
    "CACHE",
    "InjectionToken",
    "this",
    "_appConfig",
    "MechaCacheService",
    "decorators",
    "type",
    "Injectable",
    "undefined",
    "Inject",
    "args",
    "APP_CONFIG",
    "requester",
    "_a",
    "_b",
    "requestNumber",
    "_c",
    "lastRequestTimestamp",
    "Date",
    "data",
    "hash",
    "val",
    "length",
    "i",
    "charCodeAt",
    "MechaUtilService",
    "_cache",
    "_http",
    "_util",
    "_requesterHistory",
    "formatError",
    "errorStatus",
    "errorStatusText",
    "errorMessage",
    "get",
    "url",
    "catch",
    "handleResponseError",
    "map",
    "response",
    "MechaHttpResponse",
    "_this",
    "getRequestNumber",
    "getResponseJson",
    "share",
    "MechaHttpService",
    "prototype",
    "getDebounced",
    "requestSource",
    "debounceInMilliseconds",
    "debounceTime",
    "switchMap",
    "getUntil",
    "cancelToken",
    "intervalInMilliseconds",
    "numberOfIntervals",
    "getUntil$",
    "Observable",
    "interval",
    "takeUntil",
    "take",
    "getImmutable",
    "fromJS",
    "requester_1",
    "key",
    "getHashCode",
    "cachedSource_1",
    "find",
    "AsyncSubject",
    "add",
    "complete",
    "subscribe",
    "getCachedImmutable",
    "requester_2",
    "cachedImmutableSource_1",
    "throw",
    "err",
    "error",
    "HttpResponse",
    "json",
    "body",
    "HttpClient",
    "defaultConfig",
    "MechaModule",
    "forRoot",
    "ngModule",
    "providers",
    "provide",
    "useValue",
    "appConfig",
    "useClass",
    "cacheClass",
    "NgModule"
  ],
  "mappings": "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"
}
