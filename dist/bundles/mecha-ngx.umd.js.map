{
  "version": 3,
  "file": "mecha-ngx.umd.js",
  "sources": [
    "ng://mecha-ngx/out/src/app/mecha.module.ts",
    "ng://mecha-ngx/out/src/app/http/services/mecha-http/mecha-http.service.ts",
    "ng://mecha-ngx/out/src/app/shared/services/mecha-util/mecha-util.service.ts",
    "ng://mecha-ngx/out/src/app/http/models/mecha-http-response.model.ts",
    "ng://mecha-ngx/out/src/app/shared/services/mecha-cache/mecha-cache.service.ts",
    "ng://mecha-ngx/out/src/app/abstract/cache.abstract.ts"
  ],
  "sourcesContent": [
    "import { BrowserModule } from '@angular/platform-browser';\nimport { ModuleWithProviders, NgModule } from '@angular/core';\nimport { HttpClientModule } from '@angular/common/http';\n\nimport { APP_CONFIG, AppConfigInterface } from './abstract/app-config.abstract';\nimport { CACHE, CacheInterface } from './abstract/cache.abstract';\nimport { MechaCacheService } from './shared/services/mecha-cache/mecha-cache.service';\nimport { MechaHttpService } from './http/services/mecha-http/mecha-http.service';\nimport { MechaUtilService } from './shared/services/mecha-util/mecha-util.service';\n\nconst defaultConfig: AppConfigInterface = {\n  cacheTtl: 60000,\n};\n\nexport interface MechaModuleOptionsInterface {\n  appConfig?: AppConfigInterface;\n  cacheClass?: new (...args: any[]) => CacheInterface;\n}\n\n@NgModule({\n  imports: [\n    BrowserModule,\n    HttpClientModule,\n  ],\n  providers: [\n    MechaHttpService,\n    MechaUtilService,\n  ],\n})\nexport class MechaModule {\n  static forRoot({\n      appConfig = defaultConfig,\n      cacheClass = MechaCacheService,\n    }: MechaModuleOptionsInterface): ModuleWithProviders {\n    return {\n      ngModule: MechaModule,\n      providers: [\n        { provide: APP_CONFIG, useValue: appConfig },\n        { provide: CACHE, useClass: cacheClass },\n      ]\n    };\n  }\n}\n",
    "import { Inject, Injectable } from '@angular/core';\nimport { HttpClient, HttpResponse } from '@angular/common/http';\n\nimport * as Immutable from 'immutable';\nimport { AsyncSubject } from 'rxjs/AsyncSubject';\nimport { Observable } from 'rxjs/Observable';\nimport { ReplaySubject } from 'rxjs/ReplaySubject';\nimport { Subject } from 'rxjs/Subject';\nimport 'rxjs/add/observable/interval';\nimport 'rxjs/add/observable/throw';\nimport 'rxjs/add/operator/catch';\nimport 'rxjs/add/operator/debounceTime';\nimport 'rxjs/add/operator/finally';\nimport 'rxjs/add/operator/map';\nimport 'rxjs/add/operator/share';\nimport 'rxjs/add/operator/switchMap';\nimport 'rxjs/add/operator/take';\nimport 'rxjs/add/operator/takeUntil';\n\nimport { APP_CONFIG, AppConfigInterface } from '../../../abstract/app-config.abstract';\nimport { CACHE, CacheInterface } from '../../../abstract/cache.abstract';\nimport { MechaHttpResponse, MechaHttpResponseInterface } from '../../models/mecha-http-response.model';\nimport { MechaUtilService } from '../../../shared/services/mecha-util/mecha-util.service';\n\ninterface RequestNumberInterface { requestNumber: number; }\n\nconst ARBITRARY_TOKEN_VALUE = ' ';\n\n@Injectable()\nexport class MechaHttpService {\n  private _requestLookup: { [key: string]: Subject<any>} = {};\n\n  private _requesterHistory: { [key: string]: RequestNumberInterface } = {};\n\n  private _isDebouncingRequest = false;\n\n  private _debouncedSource: AsyncSubject<MechaHttpResponseInterface<any>>;\n\n  private _cachedSource: AsyncSubject<MechaHttpResponseInterface<any>>;\n\n  private _cachedImmutableSource: AsyncSubject<MechaHttpResponseInterface<any>>;\n\n  constructor(\n    @Inject(APP_CONFIG) private readonly _appConfig: AppConfigInterface,\n    @Inject(CACHE) private readonly _cache: CacheInterface,\n    private readonly _http: HttpClient,\n    private readonly _util: MechaUtilService) { }\n\n  /**\n   * Vanilla get request\n   * @param url URL to get resource from\n   *\n   * @returns The response as an observable\n  */\n  public get<T>(url: string): Observable<MechaHttpResponseInterface<T>> {\n    const requester = 'get';\n\n    return this._http\n      .get(url)\n      .catch(this.handleResponseError)\n      .map((response: HttpResponse<T>) => new MechaHttpResponse<T>({\n        requester: requester,\n        requestNumber: this.getRequestNumber(requester),\n        data: this.getResponseJson<T>(response),\n      }));\n  }\n\n  /**\n   * Share a single request amongst subscribers\n   * @param url URL to get resource from\n   *\n   * @returns The shared response as an observable\n  */\n  public getShared<T>(url: string): Observable<MechaHttpResponseInterface<T>> {\n    const requester = 'getShared';\n\n    return this._http\n      .get(url)\n      .catch(this.handleResponseError)\n      .map((response: HttpResponse<T>) => new MechaHttpResponse<T>({\n        requester: requester,\n        requestNumber: this.getRequestNumber(requester),\n        data: this.getResponseJson<T>(response),\n      }))\n      .share();\n  }\n\n  /**\n   * Thwart spammers with a debounced get\n   * @param url URL to get resource from\n   * @param [debounceInMilliseconds=1000] Length of time to debounce before submitting request\n   *\n   * @returns The debounced response as an observable\n  */\n  public getDebounced<T>(url: string, debounceInMilliseconds: number = 1000): Observable<MechaHttpResponseInterface<T>> {\n    const requester = 'getDebounced';\n\n    if (!this._isDebouncingRequest) {\n      this._debouncedSource = new AsyncSubject();\n\n      // not using switchMap because we don't want to hit backend at all until debounce completes\n      this._http.get(url)\n        .takeUntil(this._debouncedSource)\n        .debounceTime(debounceInMilliseconds)\n        .catch(this.handleResponseError)\n        .map((response: HttpResponse<T>) => new MechaHttpResponse<T>({\n          requester: requester,\n          requestNumber: this.getRequestNumber(requester),\n          data: this.getResponseJson<T>(response),\n        }))\n        .finally(() => this._isDebouncingRequest = false)\n        .subscribe(this._debouncedSource);\n    }\n\n    this._isDebouncingRequest = true;\n\n    return this._debouncedSource;\n  }\n\n /**\n   * Get responses until a condition is met, just because\n   * @param url URL to get resource from\n   * @param cancelToken Token used to cancel the interval\n   * @param [intervalInMilliseconds=1000] Length of time for each interval\n   * @param [numberOfIntervals] Number of times to execute request\n   *\n   * @returns The response in intervals as an observable\n  */\n  public getUntil<T>(url: string, cancelToken: Subject<void>, intervalInMilliseconds: number = 1000, numberOfIntervals?: number):\n    Observable<MechaHttpResponseInterface<T>> {\n    const requester = 'getUntil';\n\n    let getUntil$: Observable<number> = Observable\n      .interval(intervalInMilliseconds)\n      .takeUntil(cancelToken);\n\n    if (numberOfIntervals) {\n      getUntil$ = getUntil$.take(numberOfIntervals);\n    }\n\n    return getUntil$\n      .switchMap(() => this._http.get(url))\n      .catch(this.handleResponseError)\n      .map((response: HttpResponse<T>) => new MechaHttpResponse<T>({\n        requester: requester,\n        requestNumber: this.getRequestNumber(requester),\n        data: this.getResponseJson<T>(response),\n      }))\n      .share();\n  }\n\n  /**\n   * Make sure nothing is messing with your response\n   * @param url URL to get resource from\n   *\n   * @returns The response shared immutably as an observable\n  */\n  public getImmutable<T>(url: string): Observable<MechaHttpResponseInterface<T>> {\n    const requester = 'getImmutable';\n\n    return this._http\n      .get(url)\n      .catch(this.handleResponseError)\n      .map((response: HttpResponse<T>) => Immutable\n        .fromJS(new MechaHttpResponse<T>({\n          requester: requester,\n          requestNumber: this.getRequestNumber(requester),\n          data: this.getResponseJson<T>(response),\n        })))\n      .share()\n      .map((immutable: any) => immutable.toJS());\n  }\n\n  /**\n   * Cache a response to save trips to the backend\n   * @param url URL to get resource from\n   *\n   * @returns The cached response as an observable\n  */\n  public getCached<T>(url: string): Observable<MechaHttpResponseInterface<T>> {\n    const requester = 'getCached';\n\n    const key: number = this._util.getHashCode(url); // hashing URL and using as key in cache\n\n    const token: string = this._cache.find(key);\n\n    // if initial call or cache is expired, make fetch\n    if (token == null) {\n      this._cache.add(key, ARBITRARY_TOKEN_VALUE);\n\n      // clean up existing subject before re-initializing\n      if (this._cachedSource != null) {\n        this._cachedSource.complete();\n      }\n\n      this._cachedSource = new AsyncSubject();\n\n      this._http\n        .get(url)\n        .catch(this.handleResponseError)\n        .map((response: HttpResponse<T>) => new MechaHttpResponse<T>({\n          requester: requester,\n          requestNumber: this.getRequestNumber(requester),\n          data: this.getResponseJson<T>(response),\n        }))\n        .subscribe(this._cachedSource);\n    }\n\n    return this._cachedSource;\n  }\n\n  /**\n   * Cache a response to save trips to the backend and pass immutable copy to subscribers so they don't mess with each other\n   * @param url URL to get resource from\n   *\n   * @returns The cached response shared immutably as an observable\n  */\n  public getCachedImmutable<T>(url: string): Observable<MechaHttpResponseInterface<T>> {\n    const requester = 'getCachedImmutable';\n\n    const key: number = this._util.getHashCode(`immutable${url}`); // hashing URL and using as key in cache\n\n    const token: string = this._cache.find(key);\n\n    // if initial call or cache is expired, make fetch\n    if (token == null) {\n      this._cache.add(key, ARBITRARY_TOKEN_VALUE);\n\n      // clean up existing subject before re-initializing\n      if (this._cachedImmutableSource != null) {\n        this._cachedImmutableSource.complete();\n      }\n\n      this._cachedImmutableSource = new AsyncSubject();\n\n      this._http\n        .get(url)\n        .catch(this.handleResponseError)\n        .map((response: HttpResponse<T>) => Immutable\n          .fromJS(new MechaHttpResponse<T>({\n            requester: requester,\n            requestNumber: this.getRequestNumber(requester),\n            data: this.getResponseJson<T>(response),\n          })))\n        .subscribe(this._cachedImmutableSource);\n    }\n\n    return this._cachedImmutableSource.map((immutable: any) => immutable.toJS());\n  }\n\n  private getRequestNumber(requester: string): number {\n    return ++(this._requesterHistory[requester] = this._requesterHistory[requester] || { requestNumber: 0 }).requestNumber;\n  }\n\n  // the following are based on the Angular Http service doc\n  private getResponseJson<T>(response: HttpResponse<T>): T {\n    return response.body;\n  }\n\n  private handleResponseError(error: any): Observable<string> {\n    let errorMessage: string;\n\n    if (error instanceof HttpResponse) {\n      const json = error.body;\n\n      const err = json.error || JSON.stringify(json);\n\n      errorMessage = `${error.status}${error.statusText ? ' ' + error.statusText : ''} - ${err}`;\n    } else { errorMessage = error.message ? error.message : error.toString(); }\n\n    return Observable.throw(errorMessage);\n  }\n}\n",
    "import { Injectable } from '@angular/core';\n\n@Injectable()\nexport class MechaUtilService {\n  // http://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/\n  /**\n   * Converts a string to a hash code\n   * @param val Value to be hashed\n   *\n   * @returns Hash code generated from input value\n  */\n  public getHashCode(val: any): number {\n    if (!(typeof val === 'string' || val instanceof String)) {\n      return null;\n    }\n\n    let hash = 0;\n\n    let chr;\n\n    if (val.length === 0) {\n      return hash;\n    }\n\n    for (let i = 0; i < val.length; i++) {\n      chr = val.charCodeAt(i);\n      // tslint:disable-next-line:no-bitwise\n      hash = ((hash << 5) - hash) + chr;\n      // tslint:disable-next-line:no-bitwise\n      hash |= 0; // convert to 32-bit integer\n    }\n\n    return hash;\n  }\n}\n",
    "export class MechaHttpResponse<T> {\r\n  public requester: string;\r\n  public requestNumber: number;\r\n  public lastRequestTimestamp: Date | number;\r\n  public data: T;\r\n\r\n  constructor({\r\n    requester,\r\n    requestNumber = 1,\r\n    lastRequestTimestamp = new Date(),\r\n    data,\r\n  }: MechaHttpResponseInterface<T>) {\r\n    this.requester = requester;\r\n    this.requestNumber = requestNumber;\r\n    this.lastRequestTimestamp = lastRequestTimestamp;\r\n    this.data = data;\r\n  }\r\n}\r\n\r\nexport interface MechaHttpResponseInterface<T> {\r\n  requester: string;\r\n  requestNumber: number;\r\n  lastRequestTimestamp?: Date | number;\r\n  data: T;\r\n}\r\n",
    "import { Inject, Injectable } from '@angular/core';\r\n\r\nimport * as molar from 'molar';\r\n\r\nimport { APP_CONFIG, AppConfigInterface } from '../../../abstract/app-config.abstract';\r\nimport { CacheInterface } from '../../../abstract/cache.abstract';\r\n\r\n@Injectable()\r\nexport class MechaCacheService implements CacheInterface {\r\n  // using a simple caching library that checks for expiration on retrieval\r\n  private _cache: molar.ILookup;\r\n\r\n  constructor(@Inject(APP_CONFIG) private readonly _appConfig: AppConfigInterface) {\r\n    this._cache = new molar.Lookup(false, _appConfig.cacheTtl);\r\n  }\r\n\r\n  /**\r\n   * Adds a resource to the cache using a key\r\n   * @param key Key provided to identify the resource in the cache\r\n   * @param value Value for the resource in the cache\r\n   *\r\n   * @returns Flag indicating if resource was successfully added\r\n  */\r\n  public add(key: any, value: any): boolean {\r\n    return this._cache.add(key, value);\r\n  }\r\n\r\n  /**\r\n   * Removes a resource from the cache by key\r\n   * @param key Key provided to identify the resource in the cache\r\n   *\r\n   * @returns Flag indicating if removal was successful\r\n  */\r\n  public remove(key: any): boolean {\r\n    return this._cache.remove(key) > 0;\r\n  }\r\n\r\n  /**\r\n   * Finds a resource in the cache by key\r\n   * @param key Key provided to identify the resource in the cache\r\n   *\r\n   * @returns The matching resource, if one exists\r\n  */\r\n  public find(key: any): any {\r\n    return this._cache.find(key)[0];\r\n  }\r\n\r\n  /**\r\n   * Checks if a resource exists in the cache by key\r\n   * @param key Key provided to identify the resource in the cache\r\n   *\r\n   * @returns Flag indicating if resource exists in the cache\r\n  */\r\n  public contains(key: any): boolean {\r\n    return this._cache.contains(key);\r\n  }\r\n\r\n  /**\r\n   * Remove all resources from the cache\r\n  */\r\n  public dump(): void {\r\n    this._cache.clear();\r\n  }\r\n\r\n  /**\r\n   * Get time to live in milliseconds for resources in cache\r\n   *\r\n   * @returns Time to live in milliseconds\r\n   */\r\n  public getCacheTtl(): number {\r\n    return this._appConfig.cacheTtl;\r\n  }\r\n}\r\n",
    "import { InjectionToken } from '@angular/core';\r\n\r\nexport interface CacheInterface {\r\n    add(key: any, value: any): void | boolean;\r\n    remove(key: any): void | boolean;\r\n    find(key: any): any;\r\n    contains(key: any): boolean;\r\n    dump(): void;\r\n    getCacheTtl(): number;\r\n}\r\n\r\nexport const CACHE: InjectionToken<CacheInterface> = new InjectionToken<CacheInterface>('mechaCache');\r\n"
  ],
  "names": [
    "HttpClient",
    "HttpResponse",
    "immutable",
    "fromJS",
    "AsyncSubject",
    "Observable",
    "Inject",
    "Injectable",
    "InjectionToken"
  ],
  "mappings": "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"
}
